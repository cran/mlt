
R version 4.5.1 (2025-06-13) -- "Great Square Root"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> library("mlt")
Loading required package: basefun
Loading required package: variables
> options(digits = 4)
> 
> set.seed(29)
> n <- 1000	
> y <- rnorm(n, 2, 1.5)
> d <- data.frame(y = y)
> 
> lin <- polynomial_basis(numeric_var("y", support = range(y)), coef = c(1, 1), ci = c(-Inf, 0))
> m <- ctm(lin)
> 
> o <- mlt(m, data = d)
> 
> s2ml <- sqrt(var(y) * (n - 1) / n)
> all.equal(1 / coef(o)[2], s2ml, check.attributes = FALSE, tol = 1e-5)
[1] TRUE
> 
> all.equal(-coef(o)[1] / coef(o)[2], mean(y), check.attributes = FALSE, tol = 1e-5)
[1] TRUE
> 
> x <- runif(n, max = 2 * pi)
> y <- rnorm(n, sin(x), .25)
> d <- data.frame(y = y, x = x)
> 
> plot(x, y)
> 
> Bb <- Bernstein_basis(numeric_var("x", support = c(0, 2*pi)), order = 10, ui = "zero")
> m <- ctm(lin, shift = Bb)
Warning message:
In c.basis(bresponse = function (data, deriv = 0L)  :
  more than one basis contains an intercept term
> 
> o <- mlt(m, data = d)
> 1 / coef(o)[2]
     y 
0.2608 
> p <- predict(Bb,
+              newdata = data.frame(x = x), coef = coef(o)[-(1:2)])
> plot(x, y)
> lines(sort(x), -p[order(x)] / coef(o)[2], lwd = 2, col = "red")
> 
> x <- runif(n, max = 2 * pi)
> y <- rnorm(n, 2, 1.1 + sin(x) / 2)
> d <- data.frame(y = y, x = x)
> 
> plot(x, y)
> 
> Bb <- Bernstein_basis(numeric_var("x", support = c(0, 2*pi)), order = 10)
> m <- ctm(lin, interacting = Bb)
> 
> o <- mlt(m, data = d)
> 
> nd <- data.frame(x = sort(x))
> layout(matrix(1:2, nr = 2))
> tmp <- matrix(coef(o), nrow = 2)
> plot(nd$x, predict(Bb, nd, coef = tmp[1,]))
> plot(nd$x, predict(Bb, nd, coef = tmp[2,]))
> lines(nd$x, 1.1 + sin(nd$x) / 2, col = "red")
> 
> proc.time()
   user  system elapsed 
  0.991   0.064   1.051 
