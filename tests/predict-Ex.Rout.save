
R version 3.2.3 (2015-12-10) -- "Wooden Christmas-Tree"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> library("mlt")
Loading required package: basefun
Loading required package: variables
> set.seed(29)
> 
> n <- 100
> lcf <- c("(Intercept)" = .5, "g2" = 1, "x" = 2)
> sd <- .1
> cf <- c("y" = 1, -lcf) / sd
> cf <- cf[c("(Intercept)", "y", "g2", "x")]
> 
> d <- expand.grid(g = gl(2, 1), x = (1:n)/n)
> set.seed(29)
> d$y <- with(d, rnorm(nrow(d), 
+            mean = lcf["(Intercept)"] + lcf["g2"] * (g == "2") + lcf["x"] * x, 
+            sd = sd))
> 
> m <- ctm(polynomial_basis(numeric_var("y", support = range(d$y) * c(1, 1.1)),
+                             coef = c(TRUE, TRUE), ui = diag(2), ci = c(-Inf, 0)),
+            shift = ~ g + x, data = d)
> mod <- mlt(m, data = d, dofit = FALSE)
> coef(mod) <- cf
> 
> tfun <- function(d) with(expand.grid(d), 
+     y * cf["y"] + c(cf["(Intercept)"], sum(cf[c("(Intercept)", "g2")]))[g] + cf["x"] * x)
> pfun <- function(d) with(expand.grid(d), pnorm(y, 
+            mean = lcf["(Intercept)"] + lcf["g2"] * (g == "2") + lcf["x"] * x,
+            sd = sd))
> dfun <- function(d) with(expand.grid(d), dnorm(y, 
+            mean = lcf["(Intercept)"] + lcf["g2"] * (g == "2") + lcf["x"] * x,
+            sd = sd))
> qfun <- function(d) with(expand.grid(d), qnorm(p,
+            mean = lcf["(Intercept)"] + lcf["g2"] * (g == "2") + lcf["x"] * x,
+            sd = sd))
> 
> (ny <- mkgrid(mod, 10)$y)
 [1] 0.3916629 0.7825718 1.1734807 1.5643897 1.9552986 2.3462075 2.7371164
 [8] 3.1280254 3.5189343 3.9098432
> nd <- list(y = ny, g = gl(2, 1), x = (1:10) / 10)
> ndx <- expand.grid(nd[-1])
> end <- ndx
> end$y <- seq(from = min(d$y), to = max(d$y), length = nrow(end))
> 
> max(abs(predict(mod, newdata = end) - model.matrix(m, data = end) %*% cf))
[1] 0
> 
> cf2 <- cf
> cf2[1:2] <- 0
> max(abs(predict(mod, newdata = end, terms = "bshifting") - model.matrix(m, data = end) %*% cf2))
[1] 0
> 
> p1 <- predict(mod, newdata = ndx, q = ny)
> 
> p2 <- predict(mod, newdata = nd)
> 
> max(abs(c(p1) - c(p2)))
[1] 0
> 
> p3 <- tfun(nd)
> max(abs(c(p2) - c(p3)))
[1] 0
> 
> p1 <- predict(mod, newdata = nd, type = "distribution")
> p2 <- pfun(nd)
> max(abs(c(p1) - c(p2)))
[1] 7.771561e-16
> 
> p1 <- predict(mod, newdata = nd, type = "density")
> p2 <- dfun(nd)
> max(abs(c(p1) - c(p2)))
[1] 3.552714e-15
> 
> p1 <- predict(mod, newdata = nd, type = "quantile", p = 1:9 / 10, K = 50000)
> 
> min(apply(matrix(p1, nrow = 9), 2, diff))
[1] 0.02533471
> 
> 
> proc.time()
   user  system elapsed 
  1.992   0.076   2.063 
