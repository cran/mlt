
R version 3.6.0 (2019-04-26) -- "Planting of a Tree"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> library("mlt")
Loading required package: basefun
Loading required package: variables
> set.seed(29)
> 
> n <- 20
> ### just for interface checking
> ### we need something better!
> d <- data.frame(x1 = 1:n, x2 = sample(1:n) + 1, y = rnorm(n))
> m <- ctm(polynomial_basis(numeric_var("y", support = range(d$y)),
+                             coef = c(TRUE, TRUE), ci = c(-Inf, 0)),
+            shift = ~ x1 + x2, data = d)
> mod <- mlt(m, data = d)
> coef(mod)
(Intercept)           y          x1          x2 
-1.15423094  1.11402080  0.02335015  0.05999824 
> 
> p <- predict(mod, newdata = d)
> 
> K <- 15
> q <- mkgrid(m, n = K)[["y"]]
> p1 <- predict(mod, newdata = d[, c("x1", "x2")], q = q)
> p2 <- predict(mod, newdata = d[, c("x1", "x2")], K = K)
> stopifnot(all.equal(p1, p2))
> 
> p0 <- predict(mod$model$model, 
+     newdata = expand.grid(d), coef = coef(mod))
> p1 <- predict(mod, newdata = as.list(d))
> p2 <- predict(mod, newdata = d, q = d$y[1])
> 
> max(abs(p0 - as.vector(p1)))
[1] 0
> 
> all.equal(p1[cbind(1:n, 1:n, 1), drop = TRUE],
+           drop(p2))
[1] TRUE
> 
> all.equal(p1[cbind(1:n, 1:n, 1:n), drop = TRUE],
+           drop(p), check.attributes = FALSE)
[1] TRUE
> 
> predict(mod, newdata = list(x1 = 1:3, x2 = 2:3), prob = c(.25, .5), type = "quantile")
, , x2 =     2

       x1
prob            1         2         3
   0.25 0.3014440 0.2806353 0.2599554
    0.5 0.9074136 0.8864644 0.8655049

, , x2 =     3

       x1
prob            1         2         3
   0.25 0.2477604 0.2266262 0.2058235
    0.5 0.8535576 0.8325961 0.8116469

> 
> simulate(mod, nsim = 1, seed = 291, interpolate = FALSE)
 [1] (-1.00205738, -0.9276304] ( 0.93304398,  1.0074710]
 [3] (-0.85320343, -0.7787765] ( 1.52845978,  1.6028868]
 [5] ( 0.11434725,  0.1887742] ( 1.00747095,  1.0818979]
 [7] ( 2.19830256,        Inf] ( 1.52845978,  1.6028868]
 [9] (-0.40664158, -0.3322146] ( 0.78419003,  0.8586170]
[11] (-0.62992250, -0.5554955] (-0.33221460, -0.2577876]
[13] ( 0.63533608,  0.7097631] ( 0.33762818,  0.4120552]
[15] ( 1.00747095,  1.0818979] ( 1.00747095,  1.0818979]
[17] (       -Inf, -1.4486192] ( 0.03992027,  0.1143473]
[19] (-0.18336065, -0.1089337] ( 1.45403280,  1.5284598]
> 
> d$y <- gl(3, 1, ordered = TRUE)[rep(1:3, length = n)]
> 
> r <- as.basis(d$y) #as.basis(~ y, data = d, remove_intercept = TRUE,
> #              contrasts.arg = list(y = function(n)
> #                  contr.treatment(n, base = 3)),
> #              ui = diff(diag(2)), ci = 0)
> 
> mod2 <- mlt(ctm(r, shift = ~ x1 + x2, data = d), data = d)
> 
> predict(mod2, q = unique(d$y))
   
y         [,1]       [,2]       [,3]        [,4]       [,5]        [,6]
  1 -0.1534210 -0.4300805 -0.4719437 -0.04421458 -0.7513338 -0.08880842
  2  0.7796158  0.5029564  0.4610931  0.88882224  0.1817030  0.84422840
  3        Inf        Inf        Inf         Inf        Inf         Inf
   
y         [,7]       [,8]       [,9]      [,10]       [,11]      [,12]
  1 -0.2480698 -0.2899331 -0.7231233 -0.6475885 -0.02419586 -0.6921824
  2  0.6849670  0.6431038  0.2099135  0.2854483  0.90884095  0.2408545
  3        Inf        Inf        Inf        Inf         Inf        Inf
   
y        [,13]      [,14]      [,15]      [,16]      [,17]      [,18]
  1 -0.4209840 -0.3454492 -0.1525162 -0.2335122 -0.6275698 -0.5520350
  2  0.5120528  0.5875876  0.7805206  0.6995246  0.3054670  0.3810019
  3        Inf        Inf        Inf        Inf        Inf        Inf
   
y        [,19]      [,20]
  1 -0.5938982 -0.4009653
  2  0.3391386  0.5320715
  3        Inf        Inf
> 
> predict(mod2, prob = 1:9 / 10, type = "quantile")
  [1] 1 1 1 1 2 2 2 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 1 2 2 2 2 3 1
 [38] 1 2 2 2 3 3 3 3 1 1 1 1 2 2 2 2 3 1 1 1 1 2 2 2 3 3 1 1 1 2 2 2 2 3 3 1 1
 [75] 2 2 2 3 3 3 3 1 1 2 2 2 2 3 3 3 1 1 1 1 2 2 2 2 3 1 1 2 2 2 3 3 3 3 1 1 1
[112] 2 2 2 3 3 3 1 1 1 2 2 2 2 3 3 1 1 1 1 2 2 2 3 3 1 1 1 1 2 2 2 3 3 1 1 2 2
[149] 2 2 3 3 3 1 1 2 2 2 2 3 3 3 1 1 2 2 2 2 3 3 3 1 1 1 2 2 2 2 3 3
Levels: 1 < 2 < 3
> 
> simulate(mod2, nsim = 3, seed = 29)
[[1]]
 [1] 1 1 1 1 3 1 3 3 1 1 3 2 1 2 1 3 3 2 3 2
Levels: 1 < 2 < 3

[[2]]
 [1] 2 2 3 3 3 1 2 3 3 1 1 1 1 3 2 1 3 2 2 1
Levels: 1 < 2 < 3

[[3]]
 [1] 2 1 3 2 1 3 3 2 3 3 1 3 1 2 2 2 2 3 2 1
Levels: 1 < 2 < 3

> 
> predict(mod2, q = unique(d$y), type = "density")
       [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]
1 0.4390332 0.3335686 0.3184835 0.4823667 0.2262259 0.4646171 0.4020402
2 0.3431583 0.3589340 0.3591506 0.3305840 0.3458662 0.3361120 0.3512774
3 0.2178085 0.3074975 0.3223659 0.1870493 0.4279079 0.1992709 0.2466824
       [,8]      [,9]     [,10]     [,11]     [,12]     [,13]     [,14]
1 0.3859337 0.2348021 0.2586256 0.4903482 0.2444114 0.3368834 0.3648784
2 0.3539879 0.3483303 0.3537241 0.3279348 0.3507546 0.3588096 0.3567171
3 0.2600784 0.4168676 0.3876504 0.1817170 0.4048340 0.3043070 0.2784046
      [,15]     [,16]     [,17]     [,18]     [,19]     [,20]
1 0.4393899 0.4076818 0.2651429 0.2904622 0.2762901 0.3442228
2 0.3430678 0.3502060 0.3548519 0.3579369 0.3564572 0.3584389
3 0.2175423 0.2421121 0.3800052 0.3516009 0.3672527 0.2973382
> 
> predict(mod2, list(y = unique(d$y), x1 = 1:3, x2 = 2:3), type = "density")
, ,     2

          1         2         3
1 0.5012406 0.5001513 0.4990620
2 0.3241605 0.3245461 0.3249299
3 0.1745988 0.1753026 0.1760081

, ,     3

          1         2         3
1 0.4856321 0.4845435 0.4834550
2 0.3295122 0.3298714 0.3302286
3 0.1848557 0.1855851 0.1863163

> 
> 
> proc.time()
   user  system elapsed 
  0.880   0.055   0.929 
