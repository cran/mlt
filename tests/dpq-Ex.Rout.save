
R version 3.3.2 (2016-10-31) -- "Sincere Pumpkin Patch"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> library("mlt")
Loading required package: basefun
Loading required package: variables
> set.seed(29)
> 
> n <- 20
> ### just for interface checking
> ### we need something better!
> d <- data.frame(x1 = 1:n, x2 = sample(1:n) + 1, y = rnorm(n))
> m <- ctm(polynomial_basis(numeric_var("y", support = range(d$y)),
+                             coef = c(TRUE, TRUE), ci = c(-Inf, 0)),
+            shift = ~ x1 + x2, data = d)
> mod <- mlt(m, data = d)
> coef(mod)
 (Intercept)            y           x1           x2 
-0.605727929  1.055386378  0.027840842  0.006260632 
> 
> p <- predict(mod, newdata = d)
> 
> K <- 15
> q <- mkgrid(m, n = K)[["y"]]
> p1 <- predict(mod, newdata = d[, c("x1", "x2")], q = q)
> p2 <- predict(mod, newdata = d[, c("x1", "x2")], K = K)
> stopifnot(all.equal(p1, p2))
> 
> p0 <- predict(mod$model$model, 
+     newdata = expand.grid(d), coef = coef(mod))
> p1 <- predict(mod, newdata = as.list(d))
> p2 <- predict(mod, newdata = d, q = d$y[1])
> 
> max(abs(p0 - as.vector(p1)))
[1] 0
> 
> all.equal(p1[cbind(1:n, 1:n, 1), drop = TRUE],
+           drop(p2))
[1] TRUE
> 
> all.equal(p1[cbind(1:n, 1:n, 1:n), drop = TRUE],
+           drop(p), check.attributes = FALSE)
[1] TRUE
> 
> predict(mod, newdata = list(x1 = 1:3, x2 = 2:3), p = c(.25, .5), type = "quantile")
, , x2 =     2

       x1
p                1          2          3
   0.25 -0.1035274 -0.1301827 -0.1566080
    0.5  0.5356901  0.5093221  0.4829329

, , x2 =     3

       x1
p                1          2          3
   0.25 -0.1093401 -0.1361691 -0.1624829
    0.5  0.5297605  0.5033911  0.4769976

> 
> simulate(mod, nsim = 1, seed = 291, interpolate = FALSE)
 [1] (-1.29976527849333, -1.22533830330018] 
 [2] (1.15632490288067, 1.23075187807382]   
 [3] (-0.70434947694812, -0.629922501754969]
 [4] (1.23075187807382, 1.30517885326697]   
 [5] (0.709763051721759, 0.78419002691491]  
 [6] (0.635336076528607, 0.709763051721759] 
 [7] (2.19830255558479, Inf]                
 [8] (1.45403280365327, 1.52845977884642]   
 [9] (0.0399202749833947, 0.114347250176546]
[10] (1.30517885326697, 1.37960582846012]   
[11] (-1.22533830330018, -1.15091132810703] 
[12] (0.114347250176546, 0.188774225369698] 
[13] (0.709763051721759, 0.78419002691491]  
[14] (0.188774225369698, 0.263201200562849] 
[15] (0.635336076528607, 0.709763051721759] 
[16] (0.858617002108061, 0.933043977301213] 
[17] (-1.37419225368648, -1.29976527849333] 
[18] (0.188774225369698, 0.263201200562849] 
[19] (0.0399202749833947, 0.114347250176546]
[20] (1.52845977884642, 1.60288675403958]   
> 
> d$y <- gl(3, 1, ordered = TRUE)[rep(1:3, length = n)]
> 
> r <- as.basis(d$y) #as.basis(~ y, data = d, remove_intercept = TRUE,
> #              contrasts.arg = list(y = function(n)
> #                  contr.treatment(n, base = 3)),
> #              ui = diff(diag(2)), ci = 0)
> 
> mod2 <- mlt(ctm(r, shift = ~ x1 + x2, data = d), data = d)
> 
> predict(mod2, q = unique(d$y))
   
y        [,1]     [,2]       [,3]      [,4]       [,5]       [,6]      [,7]
  1 0.6046979 0.254511 -1.4409127 0.1146525 -0.3476375 -1.2583397 -0.599599
  2 1.7177310 1.367544 -0.3278796 1.2276856  0.7653956 -0.1453067  0.513434
  3       Inf      Inf        Inf       Inf        Inf        Inf       Inf
   
y         [,8]       [,9]     [,10]        [,11]     [,12]      [,13]
  1 -0.8376829 -0.9636637 0.3676954 -1.103522196 0.2278369 -0.5707623
  2  0.2753502  0.1493694 1.4807285  0.009510892 1.3408700  0.5422708
  3        Inf        Inf       Inf          Inf       Inf        Inf
   
y        [,14]      [,15]      [,16]      [,17]      [,18]      [,19]     [,20]
  1 -1.4814646 -0.8227239 -0.1639832 -0.2899640 -1.3127693 -0.4298225 0.4531244
  2 -0.3684315  0.2903092  0.9490499  0.8230691 -0.1997362  0.6832106 1.5661575
  3        Inf        Inf        Inf        Inf        Inf        Inf       Inf
> 
> predict(mod2, p = 1:9 / 10, type = "quantile")
  [1] 1 1 1 1 1 1 1 2 2 1 1 1 1 1 1 2 2 2 2 2 2 3 3 3 3 3 3 1 1 1 1 1 2 2 2 3 1
 [38] 1 1 2 2 2 2 3 3 1 2 2 2 3 3 3 3 3 1 1 2 2 2 2 3 3 3 1 1 2 2 2 2 3 3 3 1 2
 [75] 2 2 2 3 3 3 3 1 1 1 1 1 1 2 2 2 1 2 2 2 2 3 3 3 3 1 1 1 1 1 2 2 2 2 1 1 2
[112] 2 2 2 2 3 3 2 2 2 3 3 3 3 3 3 1 1 2 2 2 2 3 3 3 1 1 1 1 2 2 2 2 3 1 1 1 2
[149] 2 2 2 3 3 2 2 2 2 3 3 3 3 3 1 1 1 2 2 2 2 3 3 1 1 1 1 1 1 2 2 2
Levels: 1 < 2 < 3
> 
> simulate(mod2, nsim = 3, seed = 29)
[[1]]
 [1] 1 1 2 1 2 1 3 3 1 1 3 1 2 3 1 2 2 2 3 1
Levels: 1 < 2 < 3

[[2]]
 [1] 1 2 3 3 2 2 2 3 3 1 2 1 1 3 2 1 3 2 1 1
Levels: 1 < 2 < 3

[[3]]
 [1] 1 1 3 2 1 3 3 3 3 2 2 2 1 3 2 2 2 3 2 1
Levels: 1 < 2 < 3

> 
> predict(mod2, q = unique(d$y), type = "density")
        [,1]       [,2]       [,3]      [,4]      [,5]      [,6]      [,7]
1 0.72731014 0.60044961 0.07480467 0.5456397 0.3640562 0.1041345 0.2743867
2 0.22976701 0.31382298 0.29669667 0.3445778 0.4139258 0.3380999 0.4217894
3 0.04292284 0.08572741 0.62849866 0.1097825 0.2220180 0.5577656 0.3038239
       [,8]      [,9]      [,10]     [,11]      [,12]     [,13]      [,14]
1 0.2011044 0.1676073 0.64344982 0.1349002 0.59011348 0.2840804 0.06924141
2 0.4073720 0.3917616 0.28721071 0.3688940 0.31990518 0.4221036 0.28703436
3 0.3915236 0.4406311 0.06933947 0.4962058 0.08998133 0.2938160 0.64372423
      [,15]     [,16]     [,17]      [,18]     [,19]      [,20]
1 0.2053325 0.4348722 0.3859219 0.09463035 0.3336624 0.67477040
2 0.4088776 0.3938302 0.4088438 0.32621310 0.4191007 0.26657372
3 0.3857898 0.1712976 0.2052343 0.57915655 0.2472369 0.05865588
> 
> predict(mod2, list(y = unique(d$y), x1 = 1:3, x2 = 2:3), type = "density")
, ,     2

           1          2          3
1 0.76325156 0.75894822 0.75460271
2 0.20311107 0.20636324 0.20963078
3 0.03363737 0.03468853 0.03576651

, ,     3

           1          2          3
1 0.72731014 0.72267956 0.71801085
2 0.22976701 0.23311619 0.23647283
3 0.04292284 0.04420425 0.04551631

> 
> 
> proc.time()
   user  system elapsed 
  0.916   0.032   0.944 
