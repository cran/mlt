
R Under development (unstable) (2017-11-29 r73789) -- "Unsuffered Consequences"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> library("mlt")
Loading required package: basefun
Loading required package: variables
> set.seed(29)
> 
> n <- 20
> ### just for interface checking
> ### we need something better!
> d <- data.frame(x1 = 1:n, x2 = sample(1:n) + 1, y = rnorm(n))
> m <- ctm(polynomial_basis(numeric_var("y", support = range(d$y)),
+                             coef = c(TRUE, TRUE), ci = c(-Inf, 0)),
+            shift = ~ x1 + x2, data = d)
> mod <- mlt(m, data = d)
> coef(mod)
 (Intercept)            y           x1           x2 
-0.605727929  1.055386378  0.027840842  0.006260632 
> 
> p <- predict(mod, newdata = d)
> 
> K <- 15
> q <- mkgrid(m, n = K)[["y"]]
> p1 <- predict(mod, newdata = d[, c("x1", "x2")], q = q)
> p2 <- predict(mod, newdata = d[, c("x1", "x2")], K = K)
> stopifnot(all.equal(p1, p2))
> 
> p0 <- predict(mod$model$model, 
+     newdata = expand.grid(d), coef = coef(mod))
> p1 <- predict(mod, newdata = as.list(d))
> p2 <- predict(mod, newdata = d, q = d$y[1])
> 
> max(abs(p0 - as.vector(p1)))
[1] 0
> 
> all.equal(p1[cbind(1:n, 1:n, 1), drop = TRUE],
+           drop(p2))
[1] TRUE
> 
> all.equal(p1[cbind(1:n, 1:n, 1:n), drop = TRUE],
+           drop(p), check.attributes = FALSE)
[1] TRUE
> 
> predict(mod, newdata = list(x1 = 1:3, x2 = 2:3), prob = c(.25, .5), type = "quantile")
, , x2 =     2

       x1
prob             1          2          3
   0.25 -0.1035274 -0.1301827 -0.1566080
    0.5  0.5356901  0.5093221  0.4829329

, , x2 =     3

       x1
prob             1          2          3
   0.25 -0.1093401 -0.1361691 -0.1624829
    0.5  0.5297605  0.5033911  0.4769976

> 
> simulate(mod, nsim = 1, seed = 291, interpolate = FALSE)
 [1] (-1.29976527849333, -1.22533830330018] 
 [2] (1.15632490288067, 1.23075187807382]   
 [3] (-0.70434947694812, -0.629922501754969]
 [4] (1.23075187807382, 1.30517885326697]   
 [5] (0.709763051721759, 0.78419002691491]  
 [6] (0.635336076528607, 0.709763051721759] 
 [7] (2.19830255558479, Inf]                
 [8] (1.45403280365327, 1.52845977884642]   
 [9] (0.0399202749833947, 0.114347250176546]
[10] (1.30517885326697, 1.37960582846012]   
[11] (-1.22533830330018, -1.15091132810703] 
[12] (0.114347250176546, 0.188774225369698] 
[13] (0.709763051721759, 0.78419002691491]  
[14] (0.188774225369698, 0.263201200562849] 
[15] (0.635336076528607, 0.709763051721759] 
[16] (0.858617002108061, 0.933043977301213] 
[17] (-1.37419225368648, -1.29976527849333] 
[18] (0.188774225369698, 0.263201200562849] 
[19] (0.0399202749833947, 0.114347250176546]
[20] (1.52845977884642, 1.60288675403958]   
> 
> d$y <- gl(3, 1, ordered = TRUE)[rep(1:3, length = n)]
> 
> r <- as.basis(d$y) #as.basis(~ y, data = d, remove_intercept = TRUE,
> #              contrasts.arg = list(y = function(n)
> #                  contr.treatment(n, base = 3)),
> #              ui = diff(diag(2)), ci = 0)
> 
> mod2 <- mlt(ctm(r, shift = ~ x1 + x2, data = d), data = d)
> 
> predict(mod2, q = unique(d$y))
   
y       [,1]      [,2]       [,3]      [,4]       [,5]       [,6]       [,7]
  1 0.604679 0.2544987 -1.4408959 0.1146441 -0.3476374 -1.2583236 -0.5995932
  2 1.717686 1.3675055 -0.3278892 1.2276509  0.7653694 -0.1453169  0.5134136
  3      Inf       Inf        Inf       Inf        Inf        Inf        Inf
   
y         [,8]       [,9]     [,10]        [,11]     [,12]      [,13]
  1 -0.8376723 -0.9636502 0.3676875 -1.103504772 0.2278329 -0.5707522
  2  0.2753345  0.1493566 1.4806942  0.009501973 1.3408396  0.5422545
  3        Inf        Inf       Inf          Inf       Inf        Inf
   
y        [,14]      [,15]      [,16]      [,17]      [,18]      [,19]     [,20]
  1 -1.4814385 -0.8227080 -0.1639775 -0.2899554 -1.3127429 -0.4298100 0.4531228
  2 -0.3684317  0.2902987  0.9490292  0.8230513 -0.1997362  0.6831967 1.5661296
  3        Inf        Inf        Inf        Inf        Inf        Inf       Inf
> 
> predict(mod2, prob = 1:9 / 10, type = "quantile")
  [1] 1 1 1 1 1 1 1 2 2 1 1 1 1 1 1 2 2 2 2 2 2 3 3 3 3 3 3 1 1 1 1 1 2 2 2 3 1
 [38] 1 1 2 2 2 2 3 3 1 2 2 2 3 3 3 3 3 1 1 2 2 2 2 3 3 3 1 1 2 2 2 2 3 3 3 1 2
 [75] 2 2 2 3 3 3 3 1 1 1 1 1 1 2 2 2 1 2 2 2 2 3 3 3 3 1 1 1 1 1 2 2 2 2 1 1 2
[112] 2 2 2 2 3 3 2 2 2 3 3 3 3 3 3 1 1 2 2 2 2 3 3 3 1 1 1 1 2 2 2 2 3 1 1 1 2
[149] 2 2 2 3 3 2 2 2 2 3 3 3 3 3 1 1 1 2 2 2 2 3 3 1 1 1 1 1 1 2 2 2
Levels: 1 < 2 < 3
> 
> simulate(mod2, nsim = 3, seed = 29)
[[1]]
 [1] 1 1 2 1 2 1 3 3 1 1 3 1 2 3 1 2 2 2 3 1
Levels: 1 < 2 < 3

[[2]]
 [1] 1 2 3 3 2 2 2 3 3 1 2 1 1 3 2 1 3 2 1 1
Levels: 1 < 2 < 3

[[3]]
 [1] 1 1 3 2 1 3 3 3 3 2 2 2 1 3 2 2 2 3 2 1
Levels: 1 < 2 < 3

> 
> predict(mod2, q = unique(d$y), type = "density")
        [,1]       [,2]       [,3]      [,4]      [,5]      [,6]      [,7]
1 0.72730386 0.60044486 0.07480704 0.5456364 0.3640563 0.1041374 0.2743887
2 0.22976917 0.31382168 0.29669069 0.3445746 0.4139179 0.3380930 0.4217803
3 0.04292697 0.08573346 0.62850227 0.1097890 0.2220258 0.5577697 0.3038310
       [,8]      [,9]      [,10]     [,11]      [,12]     [,13]      [,14]
1 0.2011074 0.1676107 0.64344686 0.1349040 0.59011192 0.2840838 0.06924488
2 0.4073630 0.3917532 0.28720910 0.3688867 0.31990182 0.4220946 0.28703079
3 0.3915296 0.4406361 0.06934404 0.4962093 0.08998626 0.2938216 0.64372433
      [,15]     [,16]     [,17]     [,18]     [,19]      [,20]
1 0.2053370 0.4348744 0.3859252 0.0946348 0.3336669 0.67476985
2 0.4088691 0.3938227 0.4088354 0.3262087 0.4190918 0.26657101
3 0.3857939 0.1713029 0.2052394 0.5791565 0.2472413 0.05865914
> 
> predict(mod2, list(y = unique(d$y), x1 = 1:3, x2 = 2:3), type = "density")
, ,     2

          1          2          3
1 0.7632451 0.75894206 0.75459680
2 0.2031140 0.20636587 0.20963313
3 0.0336409 0.03469207 0.03577006

, ,     3

           1          2          3
1 0.72730386 0.72267356 0.71800515
2 0.22976917 0.23311806 0.23647441
3 0.04292697 0.04420838 0.04552045

> 
> 
> proc.time()
   user  system elapsed 
  3.232   0.168   3.390 
