
R version 4.0.3 (2020-10-10) -- "Bunny-Wunnies Freak Out"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> library("mlt")
Loading required package: basefun
Loading required package: variables
> library("numDeriv")
> set.seed(29)
> options(digits = 5)
> 
> n <- 20
> ### just for interface checking
> ### we need something better!
> d <- data.frame(x1 = 1:n, x2 = sample(1:n) + 1, y = rnorm(n))
> m <- ctm(polynomial_basis(numeric_var("y", support = range(d$y)),
+                             coef = c(TRUE, TRUE), ci = c(-Inf, 0)),
+            shift = ~ x1 + x2, data = d)
> mod <- mlt(m, data = d)
> coef(mod)
(Intercept)           y          x1          x2 
  -1.154231    1.114021    0.023350    0.059998 
> 
> p <- predict(mod, newdata = d)
> 
> K <- 15
> q <- mkgrid(m, n = K)[["y"]]
> p1 <- predict(mod, newdata = d[, c("x1", "x2")], q = q)
> p2 <- predict(mod, newdata = d[, c("x1", "x2")], K = K)
> stopifnot(all.equal(p1, p2))
> 
> p0 <- predict(mod$model$model, 
+     newdata = expand.grid(d), coef = coef(mod))
> p1 <- predict(mod, newdata = as.list(d))
> p2 <- predict(mod, newdata = d, q = d$y[1])
> 
> max(abs(p0 - as.vector(p1)))
[1] 0
> 
> all.equal(p1[cbind(1:n, 1:n, 1), drop = TRUE],
+           drop(p2))
[1] TRUE
> 
> all.equal(p1[cbind(1:n, 1:n, 1:n), drop = TRUE],
+           drop(p), check.attributes = FALSE)
[1] TRUE
> 
> predict(mod, newdata = list(x1 = 1:3, x2 = 2:3), prob = c(.25, .5), type = "quantile")
, , x2 =     2

       x1
prob          1       2       3
   0.25 0.30191 0.28095 0.26001
    0.5 0.90742 0.88646 0.86550

, , x2 =     3

       x1
prob          1       2       3
   0.25 0.24806 0.22709 0.20613
    0.5 0.85356 0.83260 0.81164

> 
> simulate(mod, nsim = 1, seed = 291, interpolate = FALSE)
 [1] -0.989614          0.974744         -0.781139          1.589616        
 [5]  0.161432          1.044426         (2.1983,     Inf]  1.564893        
 [9] -0.370272          0.856762         -0.599360         -0.302399        
[13]  0.654771          0.342369          1.016156          1.065057        
[17] (  -Inf, -1.4486]  0.078141         -0.172383          1.460740        
> 
> d$y <- gl(3, 1, ordered = TRUE)[rep(1:3, length = n)]
> 
> r <- as.basis(d$y) #as.basis(~ y, data = d, remove_intercept = TRUE,
> #              contrasts.arg = list(y = function(n)
> #                  contr.treatment(n, base = 3)),
> #              ui = diff(diag(2)), ci = 0)
> 
> mod2 <- mlt(ctm(r, shift = ~ x1 + x2, data = d), data = d)
> 
> predict(mod2, q = unique(d$y))
   
y       [,1]     [,2]     [,3]      [,4]     [,5]      [,6]     [,7]     [,8]
  1 -0.15342 -0.43008 -0.47194 -0.044215 -0.75133 -0.088808 -0.24807 -0.28993
  2  0.77962  0.50296  0.46109  0.888822  0.18170  0.844228  0.68497  0.64310
  3      Inf      Inf      Inf       Inf      Inf       Inf      Inf      Inf
   
y       [,9]    [,10]     [,11]    [,12]    [,13]    [,14]    [,15]    [,16]
  1 -0.72312 -0.64759 -0.024196 -0.69218 -0.42098 -0.34545 -0.15252 -0.23351
  2  0.20991  0.28545  0.908841  0.24085  0.51205  0.58759  0.78052  0.69952
  3      Inf      Inf       Inf      Inf      Inf      Inf      Inf      Inf
   
y      [,17]    [,18]    [,19]    [,20]
  1 -0.62757 -0.55203 -0.59390 -0.40097
  2  0.30547  0.38100  0.33914  0.53207
  3      Inf      Inf      Inf      Inf
> 
> predict(mod2, prob = 1:9 / 10, type = "quantile")
  [1] 1 1 1 1 2 2 2 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 1 2 2 2 2 3 1
 [38] 1 2 2 2 3 3 3 3 1 1 1 1 2 2 2 2 3 1 1 1 1 2 2 2 3 3 1 1 1 2 2 2 2 3 3 1 1
 [75] 2 2 2 3 3 3 3 1 1 2 2 2 2 3 3 3 1 1 1 1 2 2 2 2 3 1 1 2 2 2 3 3 3 3 1 1 1
[112] 2 2 2 3 3 3 1 1 1 2 2 2 2 3 3 1 1 1 1 2 2 2 3 3 1 1 1 1 2 2 2 3 3 1 1 2 2
[149] 2 2 3 3 3 1 1 2 2 2 2 3 3 3 1 1 2 2 2 2 3 3 3 1 1 1 2 2 2 2 3 3
Levels: 1 < 2 < 3
> 
> simulate(mod2, nsim = 3, seed = 29)
[[1]]
 [1] 1 1 1 1 3 1 3 3 1 1 3 2 1 2 1 3 3 2 3 2
Levels: 1 < 2 < 3

[[2]]
 [1] 2 2 3 3 3 1 2 3 3 1 1 1 1 3 2 1 3 2 2 1
Levels: 1 < 2 < 3

[[3]]
 [1] 2 1 3 2 1 3 3 2 3 3 1 3 1 2 2 2 2 3 2 1
Levels: 1 < 2 < 3

> 
> predict(mod2, q = unique(d$y), type = "density")
     [,1]    [,2]    [,3]    [,4]    [,5]    [,6]    [,7]    [,8]    [,9]
1 0.43903 0.33357 0.31848 0.48237 0.22623 0.46462 0.40204 0.38593 0.23480
2 0.34316 0.35893 0.35915 0.33058 0.34587 0.33611 0.35128 0.35399 0.34833
3 0.21781 0.30750 0.32237 0.18705 0.42791 0.19927 0.24668 0.26008 0.41687
    [,10]   [,11]   [,12]   [,13]   [,14]   [,15]   [,16]   [,17]   [,18]
1 0.25863 0.49035 0.24441 0.33688 0.36488 0.43939 0.40768 0.26514 0.29046
2 0.35372 0.32793 0.35075 0.35881 0.35672 0.34307 0.35021 0.35485 0.35794
3 0.38765 0.18172 0.40483 0.30431 0.27840 0.21754 0.24211 0.38001 0.35160
    [,19]   [,20]
1 0.27629 0.34422
2 0.35646 0.35844
3 0.36725 0.29734
> 
> predict(mod2, list(y = unique(d$y), x1 = 1:3, x2 = 2:3), type = "density")
, ,     2

        1       2       3
1 0.50124 0.50015 0.49906
2 0.32416 0.32455 0.32493
3 0.17460 0.17530 0.17601

, ,     3

        1       2       3
1 0.48563 0.48454 0.48346
2 0.32951 0.32987 0.33023
3 0.18486 0.18559 0.18632

> 
> ### some basis checks: continuous
> d <- data.frame(x1 = 1:n, x2 = sample(1:n) + 1, y = rnorm(n))
> m <- ctm(polynomial_basis(numeric_var("y", support = range(d$y)),
+                             coef = c(TRUE, TRUE), ci = c(-Inf, 0)),
+            shift = ~ x1 + x2, data = d)
> mod <- mlt(m, data = d)
> 
> .chk <- function(x)
+     stopifnot(isTRUE(max(abs(x), na.rm = TRUE) < sqrt(.Machine$double.eps)))
> 
> cont <- quote({
+ nd <- d
+ nd$y <- NULL
+ q <- mkgrid(mod, 10)[[1]]
+ p <- predict(mod, newdata = nd, q = q, type = "distribution")
+ s <- predict(mod, newdata = nd, q = q, type = "survivor")
+ .chk(predict(mod, newdata = nd, q = q, type = "distribution", log = TRUE) - log(p))
+ .chk(predict(mod, newdata = nd, q = q, type = "distribution", lower.tail = FALSE) - s)
+ .chk(predict(mod, newdata = nd, q = q, type = "distribution", lower.tail =
+ FALSE, log = TRUE) - log(s))
+ 
+ o <- predict(mod, newdata = nd, q = q, type = "odds")
+ .chk(o - p / s)
+ 
+ df <- function(q)
+     predict(mod, newdata = nd[1,], q = q, type = "distribution")
+ da <- sapply(q, function(q) grad(df, q))
+ dd <- predict(mod, newdata = nd[1,], q = q, type = "density")
+ .chk(da - dd)
+ 
+ h <- predict(mod, newdata = nd, q = q, type = "hazard")
+ .chk(predict(mod, newdata = nd, q = q, type = "loghazard") - log(h))
+ 
+ H <- predict(mod, newdata = nd, q = q, type = "cumhazard")
+ .chk(H + log(s))
+ 
+ .chk(predict(mod, newdata = nd, q = q, type = "logcumhazard") - log(H))
+ 
+ dh <- function(q)
+     predict(mod, newdata = nd[1,], q = q, type = "cumhazard")
+ 
+ da <- sapply(q, function(q) grad(dh, q))
+ dd <- predict(mod, newdata = nd[1,], q = q, type = "hazard")
+ .chk(da - dd)
+ })
> 
> m <- ctm(polynomial_basis(numeric_var("y", support = range(d$y)),
+                             coef = c(TRUE, TRUE), ci = c(-Inf, 0)),
+            shift = ~ x1 + x2, data = d, todistr = "Normal")
> mod <- mlt(m, data = d)
> 
> eval(cont)
> 
> m <- ctm(polynomial_basis(numeric_var("y", support = range(d$y)),
+                             coef = c(TRUE, TRUE), ci = c(-Inf, 0)),
+            shift = ~ x1 + x2, data = d, todistr = "Logistic")
> mod <- mlt(m, data = d)
> 
> eval(cont)
> 
> m <- ctm(polynomial_basis(numeric_var("y", support = range(d$y)),
+                             coef = c(TRUE, TRUE), ci = c(-Inf, 0)),
+            shift = ~ x1 + x2, data = d, todistr = "MinExtrVal")
> mod <- mlt(m, data = d)
> 
> eval(cont)
> 
> m <- ctm(polynomial_basis(numeric_var("y", support = range(d$y)),
+                             coef = c(TRUE, TRUE), ci = c(-Inf, 0)),
+            shift = ~ x1 + x2, data = d, todistr = "MaxExtrVal")
> mod <- mlt(m, data = d)
> 
> eval(cont)
> 
> ### some basis checks: discrete
> 
> disc <- quote({
+ nd <- d
+ nd$y <- NULL
+ q <- mkgrid(mod, 10)[[1]]
+ p <- predict(mod, newdata = nd, q = q, type = "distribution")
+ s <- predict(mod, newdata = nd, q = q, type = "survivor")
+ .chk(predict(mod, newdata = nd, q = q, type = "distribution", log = TRUE) - log(p))
+ .chk(predict(mod, newdata = nd, q = q, type = "distribution", lower.tail = FALSE) - s)
+ .chk(predict(mod, newdata = nd, q = q, type = "distribution", lower.tail =
+ FALSE, log = TRUE) - log(s))
+ 
+ o <- predict(mod, newdata = nd, q = q, type = "odds")
+ .chk(o - p / s)
+ 
+ dd <- predict(mod, newdata = nd, q = q, type = "density")
+ 
+ .chk(apply(p, 2, function(x) diff(c(0, x))) - dd)
+ 
+ h <- predict(mod, newdata = nd, q = q, type = "hazard")
+ 
+ .chk(dd / (1 - (p - dd)) - h)
+ 
+ .chk(apply(h, 2, function(x) cumprod(1 - x)) - s)
+ 
+ H <- predict(mod, newdata = nd, q = q, type = "cumhazard")
+ 
+ .chk(H + log(s))
+ })
> 
> d <- data.frame(x1 = 1:n, x2 = sample(1:n) + 1, y = sample(gl(4, 5, ordered = TRUE)))
> m <- ctm(as.basis(d$y), shift = ~ x1 + x2, data = d, todistr = "Normal")
> mod <- mlt(m, data = d)
> 
> eval(disc)
> 
> d <- data.frame(x1 = 1:n, x2 = sample(1:n) + 1, y = sample(gl(4, 5, ordered = TRUE)))
> m <- ctm(as.basis(d$y), shift = ~ x1 + x2, data = d, todistr = "Logistic")
> mod <- mlt(m, data = d)
> 
> eval(disc)
> 
> d <- data.frame(x1 = 1:n, x2 = sample(1:n) + 1, y = sample(gl(4, 5, ordered = TRUE)))
> m <- ctm(as.basis(d$y), shift = ~ x1 + x2, data = d, todistr = "MinExtrVal")
> mod <- mlt(m, data = d)
> 
> eval(disc)
> 
> d <- data.frame(x1 = 1:n, x2 = sample(1:n) + 1, y = sample(gl(4, 5, ordered = TRUE)))
> m <- ctm(as.basis(d$y), shift = ~ x1 + x2, data = d, todistr = "MaxExtrVal")
> mod <- mlt(m, data = d)
> 
> eval(disc)
> 
> 
> proc.time()
   user  system elapsed 
  6.376   0.099   6.459 
