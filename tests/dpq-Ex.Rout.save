
R version 3.6.2 (2019-12-12) -- "Dark and Stormy Night"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> library("mlt")
Loading required package: basefun
Loading required package: variables
> set.seed(29)
> options(digits = 5)
> 
> n <- 20
> ### just for interface checking
> ### we need something better!
> d <- data.frame(x1 = 1:n, x2 = sample(1:n) + 1, y = rnorm(n))
> m <- ctm(polynomial_basis(numeric_var("y", support = range(d$y)),
+                             coef = c(TRUE, TRUE), ci = c(-Inf, 0)),
+            shift = ~ x1 + x2, data = d)
> mod <- mlt(m, data = d)
> coef(mod)
(Intercept)           y          x1          x2 
  -1.154231    1.114021    0.023350    0.059998 
> 
> p <- predict(mod, newdata = d)
> 
> K <- 15
> q <- mkgrid(m, n = K)[["y"]]
> p1 <- predict(mod, newdata = d[, c("x1", "x2")], q = q)
> p2 <- predict(mod, newdata = d[, c("x1", "x2")], K = K)
> stopifnot(all.equal(p1, p2))
> 
> p0 <- predict(mod$model$model, 
+     newdata = expand.grid(d), coef = coef(mod))
> p1 <- predict(mod, newdata = as.list(d))
> p2 <- predict(mod, newdata = d, q = d$y[1])
> 
> max(abs(p0 - as.vector(p1)))
[1] 0
> 
> all.equal(p1[cbind(1:n, 1:n, 1), drop = TRUE],
+           drop(p2))
[1] TRUE
> 
> all.equal(p1[cbind(1:n, 1:n, 1:n), drop = TRUE],
+           drop(p), check.attributes = FALSE)
[1] TRUE
> 
> predict(mod, newdata = list(x1 = 1:3, x2 = 2:3), prob = c(.25, .5), type = "quantile")
, , x2 =     2

       x1
prob          1       2       3
   0.25 0.30144 0.28064 0.25996
    0.5 0.90741 0.88646 0.86550

, , x2 =     3

       x1
prob          1       2       3
   0.25 0.24776 0.22663 0.20582
    0.5 0.85356 0.83260 0.81165

> 
> simulate(mod, nsim = 1, seed = 291, interpolate = FALSE)
 [1] (-1.00206, -0.92763] ( 0.93304,  1.00747] (-0.85320, -0.77878]
 [4] ( 1.52846,  1.60289] ( 0.11435,  0.18877] ( 1.00747,  1.08190]
 [7] ( 2.19830,      Inf] ( 1.52846,  1.60289] (-0.40664, -0.33221]
[10] ( 0.78419,  0.85862] (-0.62992, -0.55550] (-0.33221, -0.25779]
[13] ( 0.63534,  0.70976] ( 0.33763,  0.41206] ( 1.00747,  1.08190]
[16] ( 1.00747,  1.08190] (    -Inf, -1.44862] ( 0.03992,  0.11435]
[19] (-0.18336, -0.10893] ( 1.45403,  1.52846]
> 
> d$y <- gl(3, 1, ordered = TRUE)[rep(1:3, length = n)]
> 
> r <- as.basis(d$y) #as.basis(~ y, data = d, remove_intercept = TRUE,
> #              contrasts.arg = list(y = function(n)
> #                  contr.treatment(n, base = 3)),
> #              ui = diff(diag(2)), ci = 0)
> 
> mod2 <- mlt(ctm(r, shift = ~ x1 + x2, data = d), data = d)
> 
> predict(mod2, q = unique(d$y))
   
y       [,1]     [,2]     [,3]      [,4]     [,5]      [,6]     [,7]     [,8]
  1 -0.15342 -0.43008 -0.47194 -0.044215 -0.75133 -0.088808 -0.24807 -0.28993
  2  0.77962  0.50296  0.46109  0.888822  0.18170  0.844228  0.68497  0.64310
  3      Inf      Inf      Inf       Inf      Inf       Inf      Inf      Inf
   
y       [,9]    [,10]     [,11]    [,12]    [,13]    [,14]    [,15]    [,16]
  1 -0.72312 -0.64759 -0.024196 -0.69218 -0.42098 -0.34545 -0.15252 -0.23351
  2  0.20991  0.28545  0.908841  0.24085  0.51205  0.58759  0.78052  0.69952
  3      Inf      Inf       Inf      Inf      Inf      Inf      Inf      Inf
   
y      [,17]    [,18]    [,19]    [,20]
  1 -0.62757 -0.55203 -0.59390 -0.40097
  2  0.30547  0.38100  0.33914  0.53207
  3      Inf      Inf      Inf      Inf
> 
> predict(mod2, prob = 1:9 / 10, type = "quantile")
  [1] 1 1 1 1 2 2 2 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 1 2 2 2 2 3 1
 [38] 1 2 2 2 3 3 3 3 1 1 1 1 2 2 2 2 3 1 1 1 1 2 2 2 3 3 1 1 1 2 2 2 2 3 3 1 1
 [75] 2 2 2 3 3 3 3 1 1 2 2 2 2 3 3 3 1 1 1 1 2 2 2 2 3 1 1 2 2 2 3 3 3 3 1 1 1
[112] 2 2 2 3 3 3 1 1 1 2 2 2 2 3 3 1 1 1 1 2 2 2 3 3 1 1 1 1 2 2 2 3 3 1 1 2 2
[149] 2 2 3 3 3 1 1 2 2 2 2 3 3 3 1 1 2 2 2 2 3 3 3 1 1 1 2 2 2 2 3 3
Levels: 1 < 2 < 3
> 
> simulate(mod2, nsim = 3, seed = 29)
[[1]]
 [1] 1 1 1 1 3 1 3 3 1 1 3 2 1 2 1 3 3 2 3 2
Levels: 1 < 2 < 3

[[2]]
 [1] 2 2 3 3 3 1 2 3 3 1 1 1 1 3 2 1 3 2 2 1
Levels: 1 < 2 < 3

[[3]]
 [1] 2 1 3 2 1 3 3 2 3 3 1 3 1 2 2 2 2 3 2 1
Levels: 1 < 2 < 3

> 
> predict(mod2, q = unique(d$y), type = "density")
     [,1]    [,2]    [,3]    [,4]    [,5]    [,6]    [,7]    [,8]    [,9]
1 0.43903 0.33357 0.31848 0.48237 0.22623 0.46462 0.40204 0.38593 0.23480
2 0.34316 0.35893 0.35915 0.33058 0.34587 0.33611 0.35128 0.35399 0.34833
3 0.21781 0.30750 0.32237 0.18705 0.42791 0.19927 0.24668 0.26008 0.41687
    [,10]   [,11]   [,12]   [,13]   [,14]   [,15]   [,16]   [,17]   [,18]
1 0.25863 0.49035 0.24441 0.33688 0.36488 0.43939 0.40768 0.26514 0.29046
2 0.35372 0.32793 0.35075 0.35881 0.35672 0.34307 0.35021 0.35485 0.35794
3 0.38765 0.18172 0.40483 0.30431 0.27840 0.21754 0.24211 0.38001 0.35160
    [,19]   [,20]
1 0.27629 0.34422
2 0.35646 0.35844
3 0.36725 0.29734
> 
> predict(mod2, list(y = unique(d$y), x1 = 1:3, x2 = 2:3), type = "density")
, ,     2

        1       2       3
1 0.50124 0.50015 0.49906
2 0.32416 0.32455 0.32493
3 0.17460 0.17530 0.17601

, ,     3

        1       2       3
1 0.48563 0.48454 0.48346
2 0.32951 0.32987 0.33023
3 0.18486 0.18559 0.18632

> 
> 
> proc.time()
   user  system elapsed 
  0.943   0.068   1.003 
